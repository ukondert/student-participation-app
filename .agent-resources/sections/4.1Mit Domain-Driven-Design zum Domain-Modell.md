## 4.1 Mit Domain-Driven-Design zum Domain-Modell

Bisher haben wir gelernt, wie man Anforderungen erhebt, in User Stories formuliert und durch Workshops mit Stakeholdern verfeinert. Doch wie gelangen wir von diesen nutzerzentrierten Anforderungen zu einem robusten technischen Fundament? Die Antwort liegt in der Erstellung eines **Domain-Modells** ‚Äì einer strukturierten Abbildung der Gesch√§ftslogik, die als solides Fundament f√ºr alle nachfolgenden Architekturentscheidungen dient.

In diesem Kapitel lernen Sie, wie Sie mit **Domain-Driven Design (DDD)** ein vollst√§ndiges Domain-Modell entwickeln, das:
- Die **Dom√§nen** Ihrer Anwendung identifiziert und nach ihrer Wichtigkeit kategorisiert (Core Domain, Supporting Subdomain, Generic Subdomain)
- F√ºr jede Dom√§ne die zentralen **Aggregate** mit ihren Entit√§ten und Value Objects definiert
- Die **Gesch√§ftslogik** in Form von Methoden den richtigen Aggregaten zuordnet
- Die **Grenzen zwischen Dom√§nen** (Bounded Contexts) klar definiert

Dieses Domain-Modell ist nicht nur eine theoretische √úbung ‚Äì es bildet die **Grundlage f√ºr die Wahl der passenden Software-Architektur(en)**. Verschiedene Dom√§nen haben unterschiedliche Anforderungen: Ihre Core Domain ben√∂tigt m√∂glicherweise eine hochflexible, wartbare Architektur (z.B. Clean Architecture), w√§hrend f√ºr Generic Subdomains eine einfache Standardl√∂sung ausreicht. Das Domain-Modell zeigt uns, wo wir in Qualit√§t investieren m√ºssen und wo Pragmatismus angebracht ist.

> <span style="font-size: 1.5em">üéØ</span> **Ziel dieses Kapitels:** Am Ende haben Sie ein vollst√§ndiges, visuell dokumentiertes Domain-Modell, das jeden Bounded Context mit seinen Aggregaten, Entit√§ten, Value Objects und deren Beziehungen zeigt ‚Äì bereit, als Blueprint f√ºr die Architekturentscheidungen.

### 4.1.1 Was ist Domain-Driven Design?

Angenommen, Sie sollen eine Software f√ºr die Logistik eines gro√üen Online-H√§ndlers entwickeln. Die Fachabteilung spricht von "Sendungsverfolgung", "Retourenmanagement" und "Lagerbestand". Wenn die Entwickler in ihrem Code jedoch nur mit generischen Begriffen wie `DataManager`, `ItemProcessor` oder `StatusUpdater` arbeiten, entsteht eine Kluft. Missverst√§ndnisse sind vorprogrammiert und die Software wird mit der Zeit immer schwerer an neue Gesch√§ftsprozesse anpassbar sein.

**Domain-Driven Design (DDD)** ist ein Ansatz zur Softwareentwicklung, der genau dieses Problem l√∂st. Es ist eine Sammlung von Prinzipien und Mustern, die darauf abzielen, eine tiefe Verbindung zwischen dem Code und dem Gesch√§ftsmodell (der **Dom√§ne**) herzustellen.

-   **Definition:** DDD ist kein spezifisches Framework, sondern eine Philosophie, die das Hauptaugenmerk auf die **Kerndom√§ne** (den wichtigsten, komplexesten Teil des Gesch√§fts) legt. Das Ziel ist es, ein reichhaltiges, ausdrucksstarkes **Modell** dieser Dom√§ne zu erstellen, das als Herzst√ºck der Software dient.
-   **Zweck:** Die drei Hauptziele von DDD sind:
    1.  **Komplexit√§t bew√§ltigen:** Indem man sich auf das Gesch√§ftsfeld konzentriert und es pr√§zise modelliert, wird die inh√§rente Komplexit√§t der Dom√§ne beherrschbar.
    2.  **Kommunikation verbessern:** DDD etabliert eine gemeinsame, allgegenw√§rtige Sprache (**Ubiquitous Language**), die von Fachexperten und Entwicklern gleicherma√üen gesprochen wird. Dies reduziert Missverst√§ndnisse drastisch.
    3.  **Langlebige Architektur schaffen:** Eine Software, deren Struktur die Dom√§ne widerspiegelt, ist leichter zu verstehen, zu warten und zu erweitern, da √Ñnderungen im Gesch√§ft sich logisch im Code abbilden lassen.

> <span style="font-size: 1.5em">:bulb:</span> **Merksatz:** Bei Domain-Driven Design geht es darum, die Sprache des Gesch√§fts zur Sprache des Codes zu machen. Die Software wird zu einem lebendigen Modell der realen Gesch√§ftsprozesse.

### 4.1.2 Die zwei S√§ulen von DDD: Strategisches und Taktisches Design

Domain-Driven Design ist kein monolithischer Block, sondern gliedert sich in zwei gro√üe, miteinander verbundene Disziplinen: **Strategisches Design** und **Taktisches Design**. Man kann sie sich wie den Plan eines St√§dtebauers und die Baupl√§ne eines einzelnen Architekten vorstellen.

1.  **Strategisches Design (Der St√§dteplaner):**
    -   **Fokus:** Das gro√üe Ganze, die Makro-Ebene. Hier geht es darum, die gesamte Gesch√§ftsdom√§ne zu verstehen und in logische, voneinander unabh√§ngige Teilbereiche zu zerlegen.
    -   **Analogie:** Der St√§dteplaner legt fest, wo das Wohngebiet, das Industriegebiet und das Einkaufsviertel liegen. Er definiert die gro√üen Verkehrsadern, die diese Gebiete verbinden, und sorgt daf√ºr, dass die Infrastruktur in jedem Viertel passt (im Wohngebiet gelten andere Anforderungen an die Infrastruktur sls im Industriegebiet).
    -   **Zentrale Fragen:** Was sind die verschiedenen Teilbereiche unseres Gesch√§fts? Wie h√§ngen sie zusammen? Wo liegen die Grenzen? Welches ist der wichtigste Teil (die Kerndom√§ne), in den wir die meiste Energie investieren m√ºssen?

2.  **Taktisches Design (Der Architekt):**
    -   **Fokus:** Das Detail, die Mikro-Ebene. Hier geht es um die konkrete Ausgestaltung des Modells *innerhalb* eines einzelnen, klar abgegrenzten Bereichs.
    -   **Analogie:** Der Architekt nimmt sich einen vom St√§dteplaner definierten Bereich ‚Äì z.B. das Wohngebiet ‚Äì und entwirft die detaillierten Baupl√§ne f√ºr ein einzelnes Haus. Er legt fest, welche R√§ume es gibt (Entit√§ten), welche Elektroanschl√ºsse, Heizk√∂rper oder √§hnliches f√ºr die R√§ume vorzusehen sind (Aggregate) und welche statische Bedingungen (Regeln) einzuhalten sind.
    -   **Zentrale Fragen:** Aus welchen Bausteinen besteht unser Modell? Wie repr√§sentieren wir ein "Kundenkonto" oder eine "Bestellung" im Code? Wie stellen wir sicher, dass Gesch√§ftsregeln (z.B. "Ein Konto kann nicht √ºberzogen werden") immer eingehalten werden?

> <span style="font-size: 1.5em">:mag:</span> **Vertiefung:** Strategisches und Taktisches Design sind untrennbar miteinander verbunden. Gutes strategisches Design schafft die Voraussetzung f√ºr effektives taktisches Design. Ohne klare Grenzen (strategisch) wird das Modell im Inneren (taktisch) chaotisch. Umgekehrt hilft die Detailarbeit im Taktischen Design oft dabei, die strategischen Grenzen besser zu verstehen und zu sch√§rfen. Man beginnt oft mit einer groben strategischen Sicht, verfeinert sie durch taktische Implementierung und passt die Strategie bei Bedarf wieder an.

### 4.1.3 Strategisches Design: Die gro√üe Landkarte

Das strategische Design ist der erste und wichtigste Schritt im DDD. Es zwingt uns, einen Schritt zur√ºckzutreten und das Gesch√§ft als Ganzes zu betrachten, bevor wir eine einzige Zeile Code schreiben. Das Ziel ist es, eine "Landkarte" der Dom√§ne zu erstellen, die uns hilft, uns zu orientieren, Grenzen zu ziehen und unsere Kr√§fte auf die wichtigsten Gebiete zu konzentrieren. Die zentralen Werkzeuge daf√ºr sind die **Kategorisierung der Dom√§nen**, die **Ubiquitous Language** und **Bounded Contexts**.

#### 4.1.3.1 Kategorisierung der Dom√§nen: Wo investieren wir unsere Energie?

Nicht alle Teile einer Software sind gleich wichtig. Manche Bereiche sind das Herzst√ºck des Gesch√§fts und bieten echte Wettbewerbsvorteile, andere sind notwendig, aber nicht differenzierend. Das strategische Design beginnt damit, die verschiedenen Teile der Gesch√§ftsdom√§ne in drei Kategorien einzuteilen, um bewusst zu entscheiden, wo die wertvollsten Entwicklungsressourcen investiert werden sollen.

**1. Core Domain (Kerndom√§ne): Das Herz des Gesch√§fts**

Die **Core Domain** ist der Teil der Dom√§ne, der den gr√∂√üten Gesch√§ftswert liefert und das Unternehmen von der Konkurrenz unterscheidet. Hier liegt die einzigartige Expertise und der Wettbewerbsvorteil.

-   **Merkmale:**
    -   Hohe fachliche Komplexit√§t
    -   St√§ndige Weiterentwicklung und √Ñnderungen
    -   Starke Einbindung von Fachexperten notwendig
    -   Gr√∂√üter Return on Investment (ROI)
-   **Strategie:** Hier investieren wir die **besten Entwickler**, die **meiste Zeit** und die **h√∂chste Qualit√§t**. Das Modell muss reichhaltig, ausdrucksstark und flexibel sein. Dies ist **nicht** der Ort f√ºr "Quick & Dirty"-L√∂sungen oder generische Frameworks.

**Beispiel Schulbibliothek:**
Der **Ausleih-Kontext** ist unsere Core Domain. Warum?
-   Er implementiert die zentralen Gesch√§ftsprozesse: Ausleihe, R√ºckgabe, Vormerkung, Mahnwesen.
-   Die Regeln sind komplex und speziell: unterschiedliche Leihfristen f√ºr Sch√ºler und Lehrer, Ausleihlimits, Strafgeb√ºhren bei versp√§teter R√ºckgabe.
-   Hier kann die Schule sich von anderen Bibliotheken unterscheiden (z.B. durch ein besonders benutzerfreundliches Vormerk-System).
-   **Investition:** Die Fachlogik f√ºr das Ausleihlimit ("Ein Sch√ºler darf maximal 5 B√ºcher ausleihen") wird als explizite Gesch√§ftsregel im `Ausleiher`-Aggregat modelliert, nicht in einer generischen Validierungsklasse versteckt.

**2. Supporting Subdomain (Unterst√ºtzende Teildom√§ne): Notwendig, aber nicht einzigartig**

Eine **Supporting Subdomain** ist ein Bereich, der f√ºr das Gesch√§ft notwendig ist, aber keinen Wettbewerbsvorteil bietet. Die Logik ist zwar spezifisch f√ºr das Unternehmen, aber nicht besonders komplex oder innovativ.

-   **Merkmale:**
    -   Mittlere fachliche Komplexit√§t
    -   Unterst√ºtzt die Core Domain
    -   Individuell, aber nicht differenzierend
    -   K√∂nnte theoretisch auch von einem anderen Unternehmen √§hnlich gel√∂st werden
-   **Strategie:** Hier investieren wir **moderate Ressourcen**. Das Modell sollte korrekt und wartbar sein, aber es rechtfertigt nicht den gleichen Perfektionismus wie die Core Domain. Oft ist es sinnvoll, hier mit weniger aufw√§ndigen Patterns zu arbeiten oder sogar Teile **outzusourcen** oder durch **Standard-Software** zu ersetzen, wenn m√∂glich.

**Beispiel Schulbibliothek:**
Der **Anschaffungs-Kontext** ist eine Supporting Subdomain. Warum?
-   Die Schule muss neue B√ºcher bestellen k√∂nnen, das ist notwendig.
-   Der Prozess (Bestellung, Rechnung, Lieferantenverwaltung) ist aber nicht einzigartig. Viele Organisationen machen √§hnliche Dinge.
-   Die Bibliothek wird nicht dadurch besser, dass sie ein super ausgefeiltes Bestellsystem hat. Ein einfaches, funktionales System reicht v√∂llig.
-   **Investition:** Ein simples CRUD-Interface (Create, Read, Update, Delete) f√ºr `BuchkatalogEintrag` mit Grundvalidierungen ist hier ausreichend. Wir ben√∂tigen kein komplexes Aggregat mit ausgefeilten Gesch√§ftsregeln.

**3. Generic Subdomain (Generische Teildom√§ne): Standard-Problem, Standard-L√∂sung**

Eine **Generic Subdomain** ist ein Bereich, f√ºr den es bereits etablierte, allgemeine L√∂sungen gibt. Die Problemstellung ist nicht spezifisch f√ºr das Unternehmen.

-   **Merkmale:**
    -   Niedrige fachliche Komplexit√§t
    -   Keine Unternehmensspezifika
    -   Standardproblem, das viele Unternehmen haben
    -   Bietet keinen Wettbewerbsvorteil
-   **Strategie:** Hier investieren wir **minimale Ressourcen**. Die beste L√∂sung ist oft, **bestehende Bibliotheken, Frameworks oder externe Services** zu nutzen (kaufen statt bauen). Wenn wir doch selbst entwickeln, halten wir es so einfach wie m√∂glich.

**Beispiel Schulbibliothek:**
Der **Nutzerprofil-Kontext** (Benutzerverwaltung, Authentifizierung) ist eine Generic Subdomain. Warum?
-   Jede Anwendung ben√∂tigt Benutzerverwaltung und Login.
-   Die Anforderungen (Benutzername, Passwort, Rollen) sind Standard.
-   Es gibt unz√§hlige fertige L√∂sungen: Identity-Server, OAuth-Provider, fertige User-Management-Bibliotheken.
-   **Investition:** Wir nutzen eine bew√§hrte Authentifizierungsl√∂sung (z.B. ASP.NET Core Identity, Keycloak, Auth0) statt ein eigenes System zu bauen. Wenn wir es doch selbst machen, ist ein einfaches Datenmodell mit `Benutzerkonto` als Entit√§t ausreichend.

> <span style="font-size: 1.5em">üîß</span> **Praxis-Tipp: Die 80/20-Regel**
>
> In den meisten Projekten macht die Core Domain nur etwa 20% des Codes aus, liefert aber 80% des Gesch√§ftswerts. Die gr√∂√üte Herausforderung im strategischen Design ist es, diese 20% zu identifizieren und **bewusst** die meisten Ressourcen darauf zu konzentrieren. Viele Projekte scheitern, weil sie ihre Energie gleichm√§√üig verteilen und am Ende √ºberall Mittelma√ü produzieren, statt in der Core Domain Exzellenz zu erreichen.

Das folgende Diagramm visualisiert die drei Dom√§nen-Kategorien mit ihren charakteristischen Eigenschaften und zeigt die Ressourcenverteilung:

```mermaid
mindmap
  root((Dom√§nen-<br/>Kategorisierung))
    Core Domain<br/>(Kerndom√§ne)
      H√∂chste Komplexit√§t
      Wettbewerbsvorteil
      Beste Entwickler
      Beispiel: Ausleih-Kontext
    Supporting Subdomain<br/>(Unterst√ºtzend)
      Mittlere Komplexit√§t
      Notwendig, nicht differenzierend
      Moderate Ressourcen
      Beispiel: Anschaffungs-Kontext
    Generic Subdomain<br/>(Generisch)
      Niedrige Komplexit√§t
      Standardproblem
      Minimale Ressourcen / Kaufen
      Beispiel: Nutzerprofil-Kontext
```

> <span style="font-size: 1.5em">:warning:</span> **Achtung: Kategorisierung ist kontextabh√§ngig!**
>
> Was f√ºr ein Unternehmen eine Core Domain ist, kann f√ºr ein anderes eine Generic Subdomain sein. F√ºr Amazon ist die Logistik (Routenoptimierung, Lagerverwaltung) eine Core Domain, da sie sich dadurch von der Konkurrenz abheben. F√ºr unsere Schulbibliothek w√§re ein komplexes Lagerverwaltungssystem v√∂llig √ºberdimensioniert ‚Äì hier w√ºrde eine einfache `Signatur` (Standort) als Value Object v√∂llig ausreichen. Die Kategorisierung muss immer aus der Perspektive des konkreten Gesch√§ftskontexts erfolgen.

#### 4.1.3.2 Ubiquitous Language (Allgegenw√§rtige Sprache)

Die gr√∂√üte Quelle f√ºr Fehler in Softwareprojekten sind Missverst√§ndnisse zwischen Fachexperten und Entwicklern. Die Fachabteilung sagt "Kunde", meint aber nur "Endverbraucher", w√§hrend die Entwickler auch "Gesch√§ftskunden" darunter verstehen. Das Ergebnis ist Chaos.

Die **Ubiquitous Language** ist die L√∂sung f√ºr dieses Problem. Es ist ein gemeinsames, von allen Projektbeteiligten ‚Äì Entwicklern, Fachexperten, Managern ‚Äì aktiv genutztes und entwickeltes Vokabular. Diese Sprache ist nicht nur eine Liste von Begriffen, sie ist die Sprache des Modells und wird direkt im Code verwendet (z.B. als Klassen- und Methodennamen).

**Beispiel: Die Schulbibliothek**
Im Workshop zur Schulbibliothek (siehe Kapitel 3.3.3) tauchten verschiedene Begriffe auf. Das Team muss sich auf eine einheitliche Sprache einigen:
-   Hei√üt es **"Vormerkung"** oder **"Reservierung"**? Das Team einigt sich auf **"Vormerkung"**, da "Reservierung" f√ºr Lehrer, die ganze Klassens√§tze bestellen, eine andere Bedeutung hat.
-   Ein Sch√ºler, der ein Buch hat, ist ein **"Ausleiher"**. Der Vorgang ist die **"Ausleihe"**.
-   Ein Buch, das nicht zur√ºckgegeben wurde, ist **"√ºberf√§llig"**. Der Prozess, den Ausleiher zu erinnern, ist das **"Mahnwesen"**.

Diese Begriffe werden nun √ºberall exakt so verwendet: in Meetings, in der Dokumentation und vor allem im Code (`class Ausleihe`, `function sendeMahnung()`).

#### 4.1.3.3 Bounded Context (Abgegrenzter Kontext)

Eine Sprache ist nur innerhalb eines bestimmten Kontextes eindeutig. Das Wort "Bank" bedeutet im Finanzwesen etwas anderes als im Park. Ein **Bounded Context** ist eine explizite Grenze (z.B. ein Modul, ein Microservice), innerhalb derer ein bestimmtes Dom√§nenmodell und eine bestimmte Ubiquitous Language gelten.

Innerhalb eines Bounded Context ist jeder Begriff eindeutig. Au√üerhalb kann er etwas v√∂llig anderes bedeuten. Das strategische Design hilft uns, diese Grenzen zu finden und zu definieren.

**Beispiel: Die Schulbibliothek**
In unsere Schulbibliotheksbeispiel gibt es nun verschiedene Arten von B√ºchern. Hier machen das durch die Namensgebung in der Ubiquitous Language explizit:

1.  **Ausleih-Kontext (Core Domain):** Das ist das Herzst√ºck. Hier geht es um das physische Exemplar im Regal.
    -   **Sprache:** `Ausleihe`, `Ausleiher`, `R√ºckgabefrist`, `Mahnung`.
    -   Das Modell hier nennen wir **`AusleihExemplar`**. Es ist eine Entit√§t mit einer eindeutigen `InventarId` und hat Attribute wie `Ausleihstatus` und `Signatur` (Standort). Es tr√§gt auch die `ISBN` als Referenz.

2.  **Anschaffungs-Kontext (Supporting Subdomain):** Hier k√ºmmert sich Frau M√ºller um die Bestellung neuer B√ºcher. Hier geht es um das Buch als bestellbares Produkt.
    -   **Sprache:** `Bestellung`, `Lieferant`, `Rechnung`, `Budget`.
    -   Das Modell hier nennen wir **`BuchkatalogEintrag`**. Es ist ebenfalls eine Entit√§t mit der `ISBN` als prim√§rer ID und hat Attribute wie `Titel`, `Preis` und `Lieferant`. Der `Ausleihstatus` ist hier v√∂llig **irrelevant**.

3.  **Nutzerprofil-Kontext (Generic Subdomain):** Hier werden die Daten der Sch√ºler und Lehrer verwaltet.
    -   **Sprache:** `Benutzerkonto`, `Passwort`, `Rolle` (Sch√ºler/Lehrer), `Klasse`.
    -   Ein `Benutzer` hat hier Attribute wie `Name` und `E-Mail`. Ob er gerade B√ºcher ausgeliehen hat, ist f√ºr diesen Kontext nicht von prim√§rem Interesse.

> <span style="font-size: 1.5em">:warning:</span> **Achtung:** Indem wir die Kontexte trennen, vermeiden wir ein riesiges "Gott-Objekt" `Buch`. Stattdessen haben wir zwei spezialisierte Modelle: das **`AusleihExemplar`** im Ausleih-Kontext und den **`BuchkatalogEintrag`** im Anschaffungs-Kontext. Die Verkn√ºpfung zwischen diesen beiden erfolgt **nicht** √ºber eine gemeinsame Klasse oder Vererbung, sondern √ºber eine **gemeinsame, stabile ID** ‚Äì die `ISBN` ist hierf√ºr der perfekte Kandidat. So kann der Ausleih-Kontext bei Bedarf Informationen (wie den Titel) aus dem Anschaffungs-Kontext abfragen, ohne dessen internes Modell kennen zu m√ºssen. Das ist die Kernidee des strategischen Designs: Komplexit√§t durch klare Grenzen und lose Kopplung beherrschen.

> <span style="font-size: 1.5em">:mag:</span> **Vertiefung: Warum keine gemeinsame Basisklasse f√ºr `Buch`?**
>
> Die intuitive Idee, eine abstrakte `Buch`-Basisklasse zu verwenden, ist ein klassisches Anti-Pattern im DDD. Der Grund liegt in der **Kopplung**:
> - **Enge Kopplung:** Eine gemeinsame Basisklasse koppelt die Kontexte eng aneinander. Eine √Ñnderung an der Basisklasse (z.B. im Anschaffungs-Team) w√ºrde sofort den Ausleih-Kontext beeinflussen und k√∂nnte dort zu Fehlern f√ºhren. Die Autonomie der Teams geht verloren.
> - **Verletzung der Grenzen:** Das Modell wird zu einem Kompromiss, der keinem Kontext richtig dient. Der Ausleih-Kontext wird mit f√ºr ihn irrelevanten Daten und Logiken aus der Anschaffung belastet und umgekehrt.
>
> Die DDD-L√∂sung ‚Äì getrennte Modelle (`AusleihExemplar`, `BuchkatalogEintrag`), die nur √ºber eine ID (`ISBN`) lose gekoppelt sind ‚Äì maximiert die **Autonomie** und **Wartbarkeit**. Jeder Kontext kann sein Modell perfekt auf seine Bed√ºrfnisse zuschneiden, ohne andere Kontexte zu beeintr√§chtigen.

### 4.1.4 Taktisches Design: Die Bausteine der Software

Nachdem das strategische Design die Landkarte und die Grenzen (Bounded Contexts) festgelegt hat, gibt uns das taktische Design die konkreten Werkzeuge an die Hand, um das Modell *innerhalb* eines Kontexts zu bauen. Dies sind die fundamentalen Bausteine, aus denen reichhaltige Dom√§nenmodelle entstehen.

#### 4.1.4.1 Entities & Value Objects: Die Grundbausteine

Jedes Modell besteht aus Objekten, aber nicht alle Objekte sind gleich. DDD unterscheidet hier fundamental zwischen zwei Arten:

1.  **Entity (Entit√§t):** Ein Objekt, das nicht durch seine Attribute, sondern durch seine **eindeutige Identit√§t** und seinen Lebenszyklus definiert wird.
    -   **Merkmal:** Es hat eine ID. Wenn sich seine Attribute √§ndern (z.B. der Nachname einer Person durch Heirat), bleibt es trotzdem dasselbe Objekt.
    -   **Beispiel Schulbibliothek:**
        -   Ein **`Ausleiher`** (Sch√ºler oder Lehrer) ist eine klassische Entit√§t. Jeder Ausleiher hat eine eindeutige Mitgliedsnummer. Auch wenn er die Klasse wechselt oder umzieht, bleibt er dieselbe Person.
        -   Das physische **`Buch`** im `Ausleih-Kontext` ist ebenfalls eine Entit√§t. Jedes einzelne Exemplar von "Harry Potter" hat eine eindeutige Inventarnummer. Es ist wichtig zu wissen, ob *genau dieses Exemplar* gerade ausgeliehen oder besch√§digt ist.

2.  **Value Object (Werteobjekt):** Ein Objekt, das durch seine Attribute definiert wird und keine eigene Identit√§t hat.
    -   **Merkmal:** Es hat keine ID. Zwei Value Objects mit denselben Attributen sind austauschbar und gleich. Sie sind oft unver√§nderlich (immutable).
    -   **Beispiel Schulbibliothek:**
        -   Die **`ISBN`** eines Buches ist ein Value Object. Zwei `ISBN`-Objekte mit dem Wert "978-3-551-55743-7" sind identisch.
        -   Eine **`Anschrift`** bestehend aus Stra√üe, PLZ und Ort ist ein Value Object. Wenn zwei Sch√ºler in derselben WG wohnen, haben sie dieselbe Anschrift. Es ist nicht wichtig, *welches* Anschrift-Objekt man verwendet, solange die Werte stimmen.
        -   Die **`R√ºckgabefrist`** ist ebenfalls ein Value Object. Sie wird durch ein Datum definiert und hat keine eigene Identit√§t.

#### 4.1.4.2 Aggregate: Die Konsistenz-Grenze

Ein zentrales Problem in komplexen Systemen ist die Einhaltung von Gesch√§ftsregeln (Invarianten), die mehrere Objekte betreffen. Zum Beispiel: "Ein Ausleiher darf nicht mehr als 5 B√ºcher gleichzeitig ausleihen."

Ein **Aggregat** ist eine Gruppe von zusammengeh√∂rigen Objekten (Entit√§ten und Value Objects), die als eine einzige Einheit f√ºr Daten√§nderungen behandelt wird. Jedes Aggregat hat eine Wurzel, die **Aggregate Root**, die als einziger Einstiegspunkt f√ºr alle Operationen auf dem Aggregat dient.

-   **Zweck:** Sicherstellung der Konsistenz. Gesch√§ftsregeln, die sich √ºber mehrere Objekte erstrecken, werden innerhalb des Aggregats garantiert.
-   **Regeln:**
    1.  Von au√üerhalb des Aggregats darf nur auf die Aggregate Root zugegriffen werden.
    2.  Objekte innerhalb des Aggregats k√∂nnen Referenzen aufeinander halten.
    3.  Nur die Aggregate Root darf von au√üerhalb referenziert werden.

**Beispiel Schulbibliothek:**
Im `Ausleih-Kontext` ist der **`Ausleiher`** eine perfekte Aggregate Root.
-   Das `Ausleiher`-Aggregat umfasst die `Ausleiher`-Entit√§t selbst und eine Liste seiner aktuellen `Ausleihe`-Objekte.
-   **Gesch√§ftsregel:** "Ein Sch√ºler darf maximal 5 B√ºcher ausleihen."
-   **Umsetzung:** Die Methode `leiheBuchAus(buch)` existiert nur auf der `Ausleiher`-Entit√§t. Bevor eine neue `Ausleihe` zur Liste hinzugef√ºgt wird, pr√ºft diese Methode: "Ist die Rolle 'Sch√ºler' UND ist die Anzahl der aktuellen Ausleihen < 5?". Nur wenn diese Bedingung erf√ºllt ist, wird die Operation ausgef√ºhrt. So wird die Regel niemals verletzt. Man kann nicht einfach von au√üen eine `Ausleihe` erzeugen und sie dem `Ausleiher` zuweisen.

#### 4.1.4.3 Repositories & Services: Zugriff und Operationen

Nachdem wir unsere Modelle mit Entities, Value Objects und Aggregaten gebaut haben, brauchen wir noch Mechanismen, um mit ihnen zu arbeiten.

1.  **Repository (Repositorium):** Dient dem Laden und Speichern von Aggregaten. Es verh√§lt sich nach au√üen wie eine Sammlung im Speicher.
    -   **Zweck:** Abstraktion der Datenbank. Das Dom√§nenmodell muss nicht wissen, ob die Daten in einer SQL-Datenbank, einer NoSQL-Datenbank oder einer Datei gespeichert werden.
    -   **Beispiel Schulbibliothek:** Es g√§be ein `IAusleiherRepository` mit Methoden wie `GetById(ausleiherId)` oder `Save(ausleiher)`. Der Code, der eine Ausleihe durchf√ºhrt, w√ºrde das `Ausleiher`-Aggregat √ºber das Repository laden, die `leiheBuchAus`-Methode aufrufen und das ge√§nderte Aggregat dann wieder √ºber das Repository speichern.

2.  **Domain Service (Dom√§nendienst):** Manchmal passt eine wichtige Gesch√§ftsoperation nicht in die Verantwortung eines einzelnen Aggregats.
    -   **Zweck:** Kapselung von Gesch√§ftslogik, die mehrere Aggregate oder externe Systeme involviert.
    -   **Beispiel Schulbibliothek:** Das **Mahnwesen**. Der Prozess "Sende allen √ºberf√§lligen Ausleihern eine Mahnung" geh√∂rt nicht zu einem einzelnen `Ausleiher`. Ein `MahnService` w√ºrde das `AusleiherRepository` nutzen, um alle relevanten Ausleiher zu laden, zu pr√ºfen, welche Ausleihen √ºberf√§llig sind, und dann z.B. einen E-Mail-Dienst aufrufen.

> <span style="font-size: 1.5em">:mag:</span> **Wichtige Frage: Wer koordiniert die Aggregate?**
>
> Man k√∂nnte annehmen, dass die `leiheBuchAus`-Methode des `Ausleiher`-Aggregats das `IAusleihExemplarRepository` ben√∂tigt, um den Zustand des Buches zu √§ndern. Dies ist jedoch ein absichtliches Anti-Pattern in DDD. Aggregate sollten niemals direkt voneinander oder von den Repositories anderer Aggregate abh√§ngig sein. Die Koordination von Operationen, die mehrere Aggregate umfassen (wie das Laden eines `Ausleihers` und eines `AusleihExemplars`), ist die Aufgabe einer √ºbergeordneten Schicht, des **Application Service**. Dieses wichtige Konzept wird im Abschnitt 4.1.6 detailliert erl√§utert.

> <span style="font-size: 1.5em">üîß</span> **Praxis-Tipp:** Das taktische Design gibt Ihnen ein m√§chtiges Vokabular, um reichhaltige, ausdrucksstarke und konsistente Dom√§nenmodelle zu bauen. Der Schl√ºssel ist, Gesch√§ftsregeln nicht in anonymen Service-Klassen zu verstecken, sondern sie so nah wie m√∂glich an die Daten zu binden, die sie sch√ºtzen ‚Äì idealerweise innerhalb eines Aggregats.

### 4.1.5 Der Weg von User Stories zum Dom√§nenmodell

Nachdem wir die Anforderungen in Form von User Stories erfasst haben (wie in Kapitel 3.3.3 beschrieben), stellt sich die Frage: Wie gelangen wir von diesen nutzerzentrierten Beschreibungen zu einem robusten, technischen Dom√§nenmodell, wie wir es im Diagramm visualisiert haben? Der Schl√ºssel liegt darin, die in den User Stories enthaltene **Ubiquitous Language** systematisch zu analysieren, um die Bausteine des taktischen Designs ‚Äì Aggregate, Entit√§ten und Value Objects ‚Äì zu identifizieren.

Dieser Prozess ist keine einmalige, lineare Transformation, sondern ein iterativer Prozess des Modellierens und Verfeinerns.

#### 4.1.5.1 Schritt 1: Nomen und Verben in User Stories identifizieren

Der erste Schritt ist, die User Stories und ihre Akzeptanzkriterien sorgf√§ltig zu "sezieren". Wir suchen nach Substantiven (Nomen) und Verben, da sie uns erste Hinweise auf die Objekte und Operationen in unserer Dom√§ne geben.

-   **Nomen** sind Kandidaten f√ºr **Aggregate, Entit√§ten oder Value Objects**.
-   **Verben** sind Kandidaten f√ºr **Methoden auf Aggregaten** oder f√ºr **Domain Services**.

Nehmen wir einige User Stories aus unserem Schulbibliothek-Workshop:

**User Story A: Buchsuche**
> "Als **Sch√ºler** m√∂chte ich online die Verf√ºgbarkeit eines **Buches** pr√ºfen k√∂nnen, um zu wissen, ob es sich lohnt, zur Bibliothek zu gehen."
> - **Akzeptanzkriterien:** Suche nach **Titel** und **Autor**, Anzeige von **Verf√ºgbarkeit** und **Standort (Signatur)**.

**User Story B: Ausleihprozess**
> "Als **Bibliothekarin** m√∂chte ich beim **Ausleihen** automatisch das korrekte **R√ºckgabedatum** berechnet bekommen, um Fehler zu vermeiden."
> - **Akzeptanzkriterien:** Unterschiedliche **Leihfristen** f√ºr **Sch√ºler** und **Lehrer**.

**User Story C: Mahnwesen**
> "Als **Bibliothekarin** m√∂chte ich t√§glich eine Liste aller √ºberf√§lligen **Ausleihen** erhalten, um rechtzeitig **Mahnungen** verschicken zu k√∂nnen."

**Identifizierte Begriffe:**
-   **Nomen:** `Sch√ºler`, `Lehrer`, `Bibliothekarin` (Rollen), `Buch`, `Titel`, `Autor`, `Verf√ºgbarkeit`, `Standort (Signatur)`, `Ausleihe`, `R√ºckgabedatum`, `Leihfrist`, `Mahnung`.
-   **Verben:** `pr√ºfen`, `suchen`, `ausleihen`, `berechnen`, `erhalten`, `verschicken`.

#### 4.1.5.2 Schritt 2: Kandidaten f√ºr Aggregate, Entit√§ten und Value Objects klassifizieren

Nun analysieren wir die identifizierten Nomen und ordnen sie den DDD-Bausteinen zu. Die zentrale Frage lautet: Hat dieses Ding eine eindeutige Identit√§t und einen Lebenszyklus, oder wird es nur durch seine Werte definiert?

-   **`Sch√ºler` / `Lehrer` / `Bibliothekarin`**: Diese haben eine eindeutige Identit√§t (eine Person bleibt dieselbe, auch wenn sich ihre Daten √§ndern). Sie sind klare Kandidaten f√ºr Entit√§ten. Da sie die Hauptakteure sind, fassen wir sie unter einem Konzept wie `Benutzerkonto` oder `Ausleiher` zusammen. Dies riecht stark nach einer **Aggregate Root**, da viele Aktionen (wie `ausleihen`) von ihnen ausgehen.
-   **`Buch`**: Hier wird es interessant. Im Kontext der Suche geht es um das Werk an sich (Titel, Autor). Im Kontext der Ausleihe geht es um das physische Exemplar im Regal. Dies ist ein starker Hinweis auf die Notwendigkeit von **Bounded Contexts**!
    -   Im `Anschaffungs-Kontext` wird daraus der **`BuchkatalogEintrag`** (ein Aggregat) mit der `ISBN` als ID.
    -   Im `Ausleih-Kontext` wird daraus das **`AusleihExemplar`** (ein Aggregat) mit einer `InventarId`.
-   **`Ausleihe`**: Eine Ausleihe hat einen klaren Lebenszyklus (erstellt, zur√ºckgegeben, √ºberf√§llig). Sie hat eine Identit√§t. Aber ist sie ein eigenes Aggregat? Wohl kaum. Eine `Ausleihe` existiert nicht ohne einen `Ausleiher` und ein `AusleihExemplar`. Sie ist eine **Entit√§t innerhalb des `Ausleiher`-Aggregats**.
-   **`Mahnung`**: √Ñhnlich wie die `Ausleihe`. Eine `Mahnung` ist an einen `Ausleiher` und eine √ºberf√§llige `Ausleihe` gebunden. Sie ist ebenfalls eine **Entit√§t im `Ausleiher`-Aggregat**.
-   **`R√ºckgabedatum` / `Leihfrist`**: Dies sind reine Werte. Ein Datum hat keine eigene Identit√§t. Zwei Objekte mit dem Wert "24.12.2025" sind identisch. Dies sind klassische **Value Objects**.
-   **`Standort (Signatur)`**: Ebenfalls ein **Value Object**. Es beschreibt einen Ort, hat aber keine eigene Identit√§t.

Das folgende Diagramm fasst diese Klassifizierung visuell zusammen und zeigt, wie die identifizierten Begriffe den verschiedenen Baustein-Typen zugeordnet werden:

```plantuml
@startuml
' Diagramm zur Klassifizierung der DDD-Bausteine

!define AGGREGATE_COLOR #90EE90
!define ENTITY_COLOR #ADD8E6
!define VALUE_OBJECT_COLOR #FFFFE0

skinparam class {
    ArrowColor #505050
    BorderColor #505050
}
skinparam package {
    BorderColor #505050
}

package "Aggregate Roots" {
    class Ausleiher <<Aggregate>> AGGREGATE_COLOR
    class AusleihExemplar <<Aggregate>> AGGREGATE_COLOR
    class BuchkatalogEintrag <<Aggregate>> AGGREGATE_COLOR
}

package "Entities (innerhalb von Aggregaten)" {
    class Ausleihe <<Entity>> ENTITY_COLOR
    class Mahnung <<Entity>> ENTITY_COLOR
}

package "Value Objects" {
    class Rueckgabedatum <<Value Object>> VALUE_OBJECT_COLOR
    class Leihfrist <<Value Object>> VALUE_OBJECT_COLOR
    class "Standort (Signatur)" as Signatur <<Value Object>> VALUE_OBJECT_COLOR
}

' Beziehung zur Verdeutlichung der Zugeh√∂rigkeit
Ausleiher "1" *-- "0..*" Ausleihe
Ausleiher "1" *-- "0..*" Mahnung

@enduml
```

#### 4.1.5.3 Schritt 3: Verhalten den Aggregaten zuordnen

Jetzt nehmen wir die identifizierten Verben und ordnen sie als Methoden den passenden Aggregaten zu. Ziel ist es, Gesch√§ftslogik und die Daten, die sie betrifft, so nah wie m√∂glich beieinander zu halten.

-   `ausleihen`: Diese Aktion √§ndert den Zustand des `Ausleihers` (er hat ein Buch mehr) und des `AusleihExemplars` (es ist nicht mehr verf√ºgbar). Die Gesch√§ftsregel "Ein Sch√ºler darf nur 5 B√ºcher ausleihen" betrifft den `Ausleiher`. Daher ist die Methode `leiheBuchAus()` am besten auf der **`Ausleiher`-Aggregate-Root** aufgehoben.
-   `berechnen (R√ºckgabedatum)`: Diese Logik geh√∂rt zum Erstellen einer `Ausleihe`. Sie wird innerhalb der `leiheBuchAus()`-Methode aufgerufen.
-   `verschicken (Mahnung)`: Geh√∂rt diese Aktion zu einem einzelnen `Ausleiher`? Nein, der Prozess "finde *alle* √ºberf√§lligen Ausleihen und verschicke Mahnungen" betrifft viele Aggregate. Dies ist ein klassischer Fall f√ºr einen **Domain Service** (`MahnService`), der mit dem `AusleiherRepository` arbeitet.

Das folgende Diagramm illustriert diese Zuordnung von Verantwortlichkeiten:

```plantuml
@startuml
' Korrigiertes Diagramm zur Zuordnung von Verhalten (Methoden)

!define AGGREGATE_COLOR #90EE90
!define ENTITY_COLOR #ADD8E6
!define SERVICE_COLOR #F5DEB3
!define REPO_COLOR #D3D3D3

skinparam class {
    ArrowColor #505050
    BorderColor #505050
}

package "Ausleih-Kontext (Core Domain)" {

    class Ausleiher <<Aggregate>> AGGREGATE_COLOR {
        --
        +leiheBuchAus(exemplarId: InventarId): void
        +gibBuchZurueck(exemplarId: InventarId): void
    }

    class Ausleihe <<Entity>> ENTITY_COLOR
    class AusleihExemplar <<Aggregate>> AGGREGATE_COLOR

    class MahnService <<Service>> SERVICE_COLOR {
        +versendeUeberfaelligeMahnungen(): void
    }

    interface IAusleiherRepository <<Repository>> REPO_COLOR {
        +findeMitUeberfaelligenAusleihen(): Ausleiher[]
        +save(ausleiher: Ausleiher): void
    }

    Ausleiher "1" *-- "0..*" Ausleihe : enth√§lt
    Ausleihe ..> AusleihExemplar : bezieht sich auf
    MahnService ..> IAusleiherRepository : nutzt
    IAusleiherRepository ..> Ausleiher : l√§dt/speichert
}
@enduml
```

> <span style="font-size: 1.5em">:mag:</span> **Vertiefung: Domain Service vs. Application Service**
>
> In diesem Zusammenhang stellt sich die Frage, ob es einen `AusleihService` geben sollte, wobei hier eine wichtige Unterscheidung zu treffen ist:
> - **Domain Service (`MahnService`):** Geh√∂rt zur **Dom√§nenschicht**. Er kapselt komplexe Gesch√§ftslogik, die **nicht in ein einzelnes Aggregat passt**, oft weil sie mehrere Aggregate koordinieren muss (z.B. "finde *alle* √ºberf√§lligen Ausleiher").
> - **Application Service (z.B. `AusleihApplicationService`):** Geh√∂rt zur **Anwendungsschicht**, also eine Ebene √ºber der Dom√§ne. Er ist der "Dirigent" f√ºr einen Anwendungsfall. Er enth√§lt keine Gesch√§ftslogik selbst, sondern orchestriert den Ablauf:
>   1.  Nimmt Anfragen von der UI entgegen (z.B. `ausleiherId`, `exemplarId`).
>   2.  Nutzt Repositories, um die ben√∂tigten Aggregate (`Ausleiher`, `AusleihExemplar`) zu laden.
>   3.  Ruft die Methoden auf den Aggregaten auf (`ausleiher.leiheBuchAus(...)`, `exemplar.wirdVerliehen()`).
>   4.  Speichert die ge√§nderten Aggregate wieder √ºber die Repositories.
>
> Der Grund, warum wir keinen `AusleihService` (als Domain Service) ben√∂tigen, ist, dass die Kernlogik der Ausleihe (z.B. die Pr√ºfung des Ausleihlimits) klar zum `Ausleiher`-Aggregat geh√∂rt. Die reine Koordination der beiden Aggregate (`Ausleiher` und `AusleihExemplar`) ist eine Aufgabe f√ºr den Application Service.
>


Das folgende Klassendiagramm zeigt die statische Struktur und die Abh√§ngigkeiten zwischen der Anwendungs- und der Dom√§nenschicht.

```plantuml
@startuml
' Klassendiagramm zur Darstellung der Anwendungs- und Dom√§nenschicht

!define APP_SERVICE_COLOR #F5DEB3
!define AGGREGATE_COLOR #90EE90
!define REPO_COLOR #D3D3D3

skinparam class {
    ArrowColor #505050
    BorderColor #505050
}
skinparam package {
    BorderColor #505050
    BackgroundColor #FFFFFF
}

package "Anwendungsschicht" {
    class AusleihApplicationService <<Service>> APP_SERVICE_COLOR {
        +sucheVerf√ºgbareB√ºcher(titel,autor) : AusleihExemplar[]
        +handleBuchAusleihen(ausleiherId, exemplarId): void
    }
}

package "Dom√§nenschicht (Ausleih-Kontext)" {
    class Ausleiher <<Aggregate>> AGGREGATE_COLOR {
        +leiheBuchAus(exemplarId): void
    }

    class AusleihExemplar <<Aggregate>> AGGREGATE_COLOR {
        +istVerf√ºgbar() : bool
        +wirdVerliehen(): void
    }

    interface IAusleiherRepository <<Repository>> REPO_COLOR
    interface IAusleihExemplarRepository <<Repository>> REPO_COLOR
}

' Beziehungen
AusleihApplicationService ..> IAusleiherRepository : nutzt
AusleihApplicationService ..> IAusleihExemplarRepository : nutzt

AusleihApplicationService ..> Ausleiher : ruft auf
AusleihApplicationService ..> AusleihExemplar : ruft auf

@enduml
```

#### 4.1.5.4 Schritt 4: Bounded Contexts definieren und verfeinern

W√§hrend der Analyse haben wir bereits festgestellt, dass der Begriff `Buch` je nach Kontext unterschiedliche Bedeutungen hat. Dies f√ºhrt uns direkt zur Definition unserer Bounded Contexts, wie im Diagramm dargestellt:

1.  **Ausleih-Kontext (Core Domain):** Hier dreht sich alles um `Ausleiher`, `AusleihExemplar`, `Ausleihe` und `Mahnung`. Die Modelle sind darauf optimiert, den Ausleih- und R√ºckgabeprozess effizient zu verwalten.
2.  **Anschaffungs-Kontext (Supporting Subdomain):** Hier existiert nur der `BuchkatalogEintrag` mit `Titel`, `Autor`, `Preis` etc. Dieses Modell ist f√ºr den Bestellprozess optimiert.
3.  **Nutzerprofil-Kontext (Generic Subdomain):** Verwaltet die Stammdaten der Benutzer (`Benutzerkonto` mit `Name`, `Rolle`, `Klasse`). Der Ausleih-Kontext referenziert diese Daten nur √ºber die `BenutzerId`.

Das Modell, aufgeteilt in seine Dom√§nen (ohne Anwendungsschicht), sieht dann wie folgt aus (*nicht vollst√§ndig*):

```plantuml
@startuml
' Finales Diagramm zur Visualisierung der Bounded Contexts mit allen Details

!define AGGREGATE_COLOR #90EE90
!define ENTITY_COLOR #ADD8E6
!define VALUE_OBJECT_COLOR #FFFFE0
!define REPO_COLOR #D3D3D3
!define SERVICE_COLOR #F5DEB3

skinparam class {
    ArrowColor #505050
    BorderColor #505050
}
skinparam package {
    BorderColor #505050
    BackgroundColor #FFFFFF
}

package "Ausleih-Kontext (Core Domain)" {
    class Ausleiher <<Aggregate>> AGGREGATE_COLOR {
        +BenutzerId: UUID
        +Name: string
        +Rolle: string
        --
        +leiheBuchAus(exemplarId: InventarId): void
        +gibBuchZurueck(exemplarId: InventarId): void
        +verlaengereAusleihe(ausleihId: UUID): void
    }
    class Ausleihe <<Entity>> ENTITY_COLOR {
        -AusleihId: UUID
        -Ausleihdatum: Date
    }
    class Mahnung <<Entity>> ENTITY_COLOR {
        -MahnungsId: UUID
        -Mahnstufe: int
    }

    class AusleihExemplar <<Aggregate>> AGGREGATE_COLOR {
        +InventarId: UUID
         --
        +istVerf√ºgbar():bool
        +wirdVerliehen()
    }
    
    class Rueckgabedatum <<Value Object>> VALUE_OBJECT_COLOR {
        +Datum: Date
    }
    class Leihfrist <<Value Object>> VALUE_OBJECT_COLOR {
        +Tage: int
    }
    class Signatur <<Value Object>> VALUE_OBJECT_COLOR {
        +Wert: string
    }
    class ISBN <<Value Object>> VALUE_OBJECT_COLOR {
        +isbn: string
        ---
        {static}validate(isbn):bool
    }
    class Geldbetrag <<Value Object>> VALUE_OBJECT_COLOR {
       +Betrag: decimal
       +Waehrung: string
    }
    enum AusleihStatus <<Value Object>> VALUE_OBJECT_COLOR {
        VERF√úGBAR
        NICHT_VERF√úGBAR
        VORGEMERKT
    }

    interface IAusleiherRepository <<Repository>> REPO_COLOR
    interface IAusleihExemplarRepository <<Repository>> REPO_COLOR
    class MahnService <<Service>> SERVICE_COLOR

    Ausleiher "1" *-- "0..*" Ausleihe : enth√§lt
    Ausleiher "1" *-- "0..*" Mahnung : enth√§lt
    Ausleihe ..> AusleihExemplar : bezieht sich auf
    Ausleihe --> Rueckgabedatum
    Ausleihe --> Leihfrist
    Mahnung --> Geldbetrag
    AusleihExemplar --> Signatur
    AusleihExemplar --> AusleihStatus
    AusleihExemplar --> ISBN
    
    MahnService ..> IAusleiherRepository : nutzt
    IAusleiherRepository ..> Ausleiher : l√§dt/speichert
    IAusleihExemplarRepository ..> AusleihExemplar : l√§dt/speichert
}

package "Anschaffungs-Kontext (Supporting Subdomain)" {
    class BuchkatalogEintrag <<Aggregate>> AGGREGATE_COLOR {
        +ISBN: string
        +Titel: string
        +Autor: string
    }
    class Geldbetrag <<Value Object>> VALUE_OBJECT_COLOR {
       +Betrag: decimal
       +Waehrung: string
    }
    BuchkatalogEintrag --> Geldbetrag
}

package "Nutzerprofil-Kontext (Generic Subdomain)" {
    class Benutzerkonto <<Aggregate>> AGGREGATE_COLOR {
        +BenutzerId: UUID
        +Name: string
        +Rolle: string
    }
}

' Beziehungen zwischen den Bounded Contexts
Ausleiher ..> Benutzerkonto : (BenutzerId)
AusleihExemplar ..> BuchkatalogEintrag : (ISBN)

@enduml
```

#### 4.1.5.5 Legende zum Diagramm
Das Diagramm verwendet eine an UML angelehnte Notation mit spezifischen Konventionen f√ºr DDD, um die Bausteine klar zu kennzeichnen:

-   <span style="display:inline-block; width:15px; height:15px; background-color:#90EE90; border:1px solid #505050; vertical-align: middle;"></span> : Stellen **Aggregate Roots** dar. Sie sind die Hauptzugangspunkte zu einem Konsistenzbereich und kapseln Gesch√§ftsregeln.
-   <span style="display:inline-block; width:15px; height:15px; background-color:#ADD8E6; border:1px solid #505050; vertical-align: middle;"></span> (`<<Entity>>`)**: Sind **Entit√§ten** innerhalb eines Aggregats. Sie haben eine eigene Identit√§t, werden aber immer √ºber die Aggregate Root verwaltet.
-   <span style="display:inline-block; width:15px; height:15px; background-color:#FFFFE0; border:1px solid #505050; vertical-align: middle;"></span> (`<<Value Object>>`): Sind **Value Objects**, die durch ihre Werte definiert sind und keine eigene Identit√§t besitzen.
-   <span style="display:inline-block; width:15px; height:15px; background-color:#F5DEB3; border:1px solid #505050; vertical-align: middle;"></span> (`<<Service>>`): Kennzeichnen **Domain Services**, die Gesch√§ftslogik kapseln, die nicht in ein einzelnes Aggregat passt.
-   <span style="display:inline-block; width:15px; height:15px; background-color:#D3D3D3; border:1px solid #505050; vertical-align: middle;"></span> (`<<Repository>>`): Stehen f√ºr **Repositories**, die f√ºr das Laden und Speichern von Aggregaten zust√§ndig sind und die Persistenzschicht abstrahieren.
-   **Gestrichelter Pfeil (`..>`)**: Stellt eine lose Kopplung dar ‚Äì eine Referenz √ºber eine ID auf eine andere **Aggregate Root**, oft √ºber die Grenze eines Bounded Context hinweg.
-   **Raute mit durchgezogener Linie (`*--`)**: Symbolisiert eine **Komposition**. Die Aggregate Root "enth√§lt" eine oder mehrere Entit√§ten und ist f√ºr deren Lebenszyklus verantwortlich.
-   **Durchgezogener Pfeil (`-->`)**: Zeigt an, dass eine Entit√§t ein **Value Object** verwendet.

Durch diesen iterativen Prozess des Analysierens, Klassifizierens und Zuordnens entsteht aus den anf√§nglich einfachen User Stories schrittweise ein reichhaltiges und robustes Dom√§nenmodell, das die Komplexit√§t des Gesch√§ftsfeldes abbildet und f√ºr zuk√ºnftige Erweiterungen gewappnet ist.
